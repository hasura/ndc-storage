// Code generated by github.com/hasura/ndc-sdk-go/cmd/hasura-ndc-go, DO NOT EDIT.
package functions

import (
	"context"
	"encoding/json"
	"github.com/hasura/ndc-sdk-go/connector"
	"github.com/hasura/ndc-sdk-go/schema"
	"github.com/hasura/ndc-sdk-go/utils"
	"github.com/hasura/ndc-storage/connector/storage/common"
	"github.com/hasura/ndc-storage/connector/types"
	"go.opentelemetry.io/otel/trace"
	"log/slog"
	"slices"
)

// DataConnectorHandler implements the data connector handler
type DataConnectorHandler struct{}

// QueryExists check if the query name exists
func (dch DataConnectorHandler) QueryExists(name string) bool {
	return slices.Contains(enumValues_FunctionName, name)
}
func (dch DataConnectorHandler) Query(ctx context.Context, state *types.State, request *schema.QueryRequest, rawArgs map[string]any) (*schema.RowSet, error) {
	if !dch.QueryExists(request.Collection) {
		return nil, utils.ErrHandlerNotfound
	}
	queryFields, err := utils.EvalFunctionSelectionFieldValue(request)
	if err != nil {
		return nil, schema.UnprocessableContentError(err.Error(), nil)
	}

	result, err := dch.execQuery(context.WithValue(ctx, utils.CommandSelectionFieldKey, queryFields), state, request, queryFields, rawArgs)
	if err != nil {
		return nil, err
	}

	return &schema.RowSet{
		Aggregates: schema.RowSetAggregates{},
		Rows: []map[string]any{
			{
				"__value": result,
			},
		},
	}, nil
}

func (dch DataConnectorHandler) execQuery(ctx context.Context, state *types.State, request *schema.QueryRequest, queryFields schema.NestedField, rawArgs map[string]any) (any, error) {
	span := trace.SpanFromContext(ctx)
	logger := connector.GetLogger(ctx)
	switch request.Collection {
	case "downloadStorageObject":

		if len(queryFields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.GetStorageObjectOptions
		parseErr := args.FromValue(rawArgs)
		if parseErr != nil {
			return nil, schema.UnprocessableContentError("failed to resolve arguments", map[string]any{
				"cause": parseErr.Error(),
			})
		}

		connector_addSpanEvent(span, logger, "execute_function", map[string]any{
			"arguments": args,
		})
		return FunctionDownloadStorageObject(ctx, state, &args)

	case "downloadStorageObjectText":

		if len(queryFields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.GetStorageObjectOptions
		parseErr := args.FromValue(rawArgs)
		if parseErr != nil {
			return nil, schema.UnprocessableContentError("failed to resolve arguments", map[string]any{
				"cause": parseErr.Error(),
			})
		}

		connector_addSpanEvent(span, logger, "execute_function", map[string]any{
			"arguments": args,
		})
		return FunctionDownloadStorageObjectText(ctx, state, &args)

	case "storageBucketEncryption":

		selection, err := queryFields.AsObject()
		if err != nil {
			return nil, schema.UnprocessableContentError("the selection field type must be object", map[string]any{
				"cause": err.Error(),
			})
		}
		var args common.StorageBucketArguments
		parseErr := args.FromValue(rawArgs)
		if parseErr != nil {
			return nil, schema.UnprocessableContentError("failed to resolve arguments", map[string]any{
				"cause": parseErr.Error(),
			})
		}

		connector_addSpanEvent(span, logger, "execute_function", map[string]any{
			"arguments": args,
		})
		rawResult, err := FunctionStorageBucketEncryption(ctx, state, &args)

		if err != nil {
			return nil, err
		}

		if rawResult == nil {
			return nil, nil
		}
		connector_addSpanEvent(span, logger, "evaluate_response_selection", map[string]any{
			"raw_result": rawResult,
		})
		result, err := utils.EvalNestedColumnObject(selection, rawResult)
		if err != nil {
			return nil, err
		}
		return result, nil

	case "storageBucketExists":

		if len(queryFields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.StorageBucketArguments
		parseErr := args.FromValue(rawArgs)
		if parseErr != nil {
			return nil, schema.UnprocessableContentError("failed to resolve arguments", map[string]any{
				"cause": parseErr.Error(),
			})
		}

		connector_addSpanEvent(span, logger, "execute_function", map[string]any{
			"arguments": args,
		})
		return FunctionStorageBucketExists(ctx, state, &args)

	case "storageBucketLifecycle":

		selection, err := queryFields.AsObject()
		if err != nil {
			return nil, schema.UnprocessableContentError("the selection field type must be object", map[string]any{
				"cause": err.Error(),
			})
		}
		var args common.StorageBucketArguments
		parseErr := args.FromValue(rawArgs)
		if parseErr != nil {
			return nil, schema.UnprocessableContentError("failed to resolve arguments", map[string]any{
				"cause": parseErr.Error(),
			})
		}

		connector_addSpanEvent(span, logger, "execute_function", map[string]any{
			"arguments": args,
		})
		rawResult, err := FunctionStorageBucketLifecycle(ctx, state, &args)

		if err != nil {
			return nil, err
		}

		if rawResult == nil {
			return nil, nil
		}
		connector_addSpanEvent(span, logger, "evaluate_response_selection", map[string]any{
			"raw_result": rawResult,
		})
		result, err := utils.EvalNestedColumnObject(selection, rawResult)
		if err != nil {
			return nil, err
		}
		return result, nil

	case "storageBucketNotification":

		selection, err := queryFields.AsObject()
		if err != nil {
			return nil, schema.UnprocessableContentError("the selection field type must be object", map[string]any{
				"cause": err.Error(),
			})
		}
		var args common.StorageBucketArguments
		parseErr := args.FromValue(rawArgs)
		if parseErr != nil {
			return nil, schema.UnprocessableContentError("failed to resolve arguments", map[string]any{
				"cause": parseErr.Error(),
			})
		}

		connector_addSpanEvent(span, logger, "execute_function", map[string]any{
			"arguments": args,
		})
		rawResult, err := FunctionStorageBucketNotification(ctx, state, &args)

		if err != nil {
			return nil, err
		}

		if rawResult == nil {
			return nil, nil
		}
		connector_addSpanEvent(span, logger, "evaluate_response_selection", map[string]any{
			"raw_result": rawResult,
		})
		result, err := utils.EvalNestedColumnObject(selection, rawResult)
		if err != nil {
			return nil, err
		}
		return result, nil

	case "storageBucketPolicy":

		if len(queryFields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.StorageBucketArguments
		parseErr := args.FromValue(rawArgs)
		if parseErr != nil {
			return nil, schema.UnprocessableContentError("failed to resolve arguments", map[string]any{
				"cause": parseErr.Error(),
			})
		}

		connector_addSpanEvent(span, logger, "execute_function", map[string]any{
			"arguments": args,
		})
		return FunctionStorageBucketPolicy(ctx, state, &args)

	case "storageBucketReplication":

		selection, err := queryFields.AsObject()
		if err != nil {
			return nil, schema.UnprocessableContentError("the selection field type must be object", map[string]any{
				"cause": err.Error(),
			})
		}
		var args common.StorageBucketArguments
		parseErr := args.FromValue(rawArgs)
		if parseErr != nil {
			return nil, schema.UnprocessableContentError("failed to resolve arguments", map[string]any{
				"cause": parseErr.Error(),
			})
		}

		connector_addSpanEvent(span, logger, "execute_function", map[string]any{
			"arguments": args,
		})
		rawResult, err := FunctionStorageBucketReplication(ctx, state, &args)

		if err != nil {
			return nil, err
		}

		if rawResult == nil {
			return nil, nil
		}
		connector_addSpanEvent(span, logger, "evaluate_response_selection", map[string]any{
			"raw_result": rawResult,
		})
		result, err := utils.EvalNestedColumnObject(selection, rawResult)
		if err != nil {
			return nil, err
		}
		return result, nil

	case "storageBucketTags":

		if len(queryFields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.StorageBucketArguments
		parseErr := args.FromValue(rawArgs)
		if parseErr != nil {
			return nil, schema.UnprocessableContentError("failed to resolve arguments", map[string]any{
				"cause": parseErr.Error(),
			})
		}

		connector_addSpanEvent(span, logger, "execute_function", map[string]any{
			"arguments": args,
		})
		return FunctionStorageBucketTags(ctx, state, &args)

	case "storageBucketVersioning":

		selection, err := queryFields.AsObject()
		if err != nil {
			return nil, schema.UnprocessableContentError("the selection field type must be object", map[string]any{
				"cause": err.Error(),
			})
		}
		var args common.StorageBucketArguments
		parseErr := args.FromValue(rawArgs)
		if parseErr != nil {
			return nil, schema.UnprocessableContentError("failed to resolve arguments", map[string]any{
				"cause": parseErr.Error(),
			})
		}

		connector_addSpanEvent(span, logger, "execute_function", map[string]any{
			"arguments": args,
		})
		rawResult, err := FunctionStorageBucketVersioning(ctx, state, &args)

		if err != nil {
			return nil, err
		}

		if rawResult == nil {
			return nil, nil
		}
		connector_addSpanEvent(span, logger, "evaluate_response_selection", map[string]any{
			"raw_result": rawResult,
		})
		result, err := utils.EvalNestedColumnObject(selection, rawResult)
		if err != nil {
			return nil, err
		}
		return result, nil

	case "storageBuckets":

		selection, err := queryFields.AsArray()
		if err != nil {
			return nil, schema.UnprocessableContentError("the selection field type must be array", map[string]any{
				"cause": err.Error(),
			})
		}
		var args common.ListStorageBucketArguments
		parseErr := args.FromValue(rawArgs)
		if parseErr != nil {
			return nil, schema.UnprocessableContentError("failed to resolve arguments", map[string]any{
				"cause": parseErr.Error(),
			})
		}

		connector_addSpanEvent(span, logger, "execute_function", map[string]any{
			"arguments": args,
		})
		rawResult, err := FunctionStorageBuckets(ctx, state, &args)

		if err != nil {
			return nil, err
		}

		connector_addSpanEvent(span, logger, "evaluate_response_selection", map[string]any{
			"raw_result": rawResult,
		})
		result, err := utils.EvalNestedColumnArrayIntoSlice(selection, rawResult)
		if err != nil {
			return nil, err
		}
		return result, nil

	case "storageIncompleteUploads":

		selection, err := queryFields.AsArray()
		if err != nil {
			return nil, schema.UnprocessableContentError("the selection field type must be array", map[string]any{
				"cause": err.Error(),
			})
		}
		var args common.ListIncompleteUploadsArguments
		parseErr := args.FromValue(rawArgs)
		if parseErr != nil {
			return nil, schema.UnprocessableContentError("failed to resolve arguments", map[string]any{
				"cause": parseErr.Error(),
			})
		}

		connector_addSpanEvent(span, logger, "execute_function", map[string]any{
			"arguments": args,
		})
		rawResult, err := FunctionStorageIncompleteUploads(ctx, state, &args)

		if err != nil {
			return nil, err
		}

		connector_addSpanEvent(span, logger, "evaluate_response_selection", map[string]any{
			"raw_result": rawResult,
		})
		result, err := utils.EvalNestedColumnArrayIntoSlice(selection, rawResult)
		if err != nil {
			return nil, err
		}
		return result, nil

	case "storageObject":

		selection, err := queryFields.AsObject()
		if err != nil {
			return nil, schema.UnprocessableContentError("the selection field type must be object", map[string]any{
				"cause": err.Error(),
			})
		}
		var args common.GetStorageObjectOptions
		parseErr := args.FromValue(rawArgs)
		if parseErr != nil {
			return nil, schema.UnprocessableContentError("failed to resolve arguments", map[string]any{
				"cause": parseErr.Error(),
			})
		}

		connector_addSpanEvent(span, logger, "execute_function", map[string]any{
			"arguments": args,
		})
		rawResult, err := FunctionStorageObject(ctx, state, &args)

		if err != nil {
			return nil, err
		}

		if rawResult == nil {
			return nil, nil
		}
		connector_addSpanEvent(span, logger, "evaluate_response_selection", map[string]any{
			"raw_result": rawResult,
		})
		result, err := utils.EvalNestedColumnObject(selection, rawResult)
		if err != nil {
			return nil, err
		}
		return result, nil

	case "storageObjectAttributes":

		selection, err := queryFields.AsObject()
		if err != nil {
			return nil, schema.UnprocessableContentError("the selection field type must be object", map[string]any{
				"cause": err.Error(),
			})
		}
		var args common.StorageObjectAttributesOptions
		parseErr := args.FromValue(rawArgs)
		if parseErr != nil {
			return nil, schema.UnprocessableContentError("failed to resolve arguments", map[string]any{
				"cause": parseErr.Error(),
			})
		}

		connector_addSpanEvent(span, logger, "execute_function", map[string]any{
			"arguments": args,
		})
		rawResult, err := FunctionStorageObjectAttributes(ctx, state, &args)

		if err != nil {
			return nil, err
		}

		if rawResult == nil {
			return nil, nil
		}
		connector_addSpanEvent(span, logger, "evaluate_response_selection", map[string]any{
			"raw_result": rawResult,
		})
		result, err := utils.EvalNestedColumnObject(selection, rawResult)
		if err != nil {
			return nil, err
		}
		return result, nil

	case "storageObjectLegalHold":

		if len(queryFields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.GetStorageObjectLegalHoldOptions
		parseErr := args.FromValue(rawArgs)
		if parseErr != nil {
			return nil, schema.UnprocessableContentError("failed to resolve arguments", map[string]any{
				"cause": parseErr.Error(),
			})
		}

		connector_addSpanEvent(span, logger, "execute_function", map[string]any{
			"arguments": args,
		})
		return FunctionStorageObjectLegalHold(ctx, state, &args)

	case "storageObjectLockConfig":

		selection, err := queryFields.AsObject()
		if err != nil {
			return nil, schema.UnprocessableContentError("the selection field type must be object", map[string]any{
				"cause": err.Error(),
			})
		}
		var args common.StorageBucketArguments
		parseErr := args.FromValue(rawArgs)
		if parseErr != nil {
			return nil, schema.UnprocessableContentError("failed to resolve arguments", map[string]any{
				"cause": parseErr.Error(),
			})
		}

		connector_addSpanEvent(span, logger, "execute_function", map[string]any{
			"arguments": args,
		})
		rawResult, err := FunctionStorageObjectLockConfig(ctx, state, &args)

		if err != nil {
			return nil, err
		}

		if rawResult == nil {
			return nil, nil
		}
		connector_addSpanEvent(span, logger, "evaluate_response_selection", map[string]any{
			"raw_result": rawResult,
		})
		result, err := utils.EvalNestedColumnObject(selection, rawResult)
		if err != nil {
			return nil, err
		}
		return result, nil

	case "storageObjectTags":

		if len(queryFields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.StorageObjectTaggingOptions
		parseErr := args.FromValue(rawArgs)
		if parseErr != nil {
			return nil, schema.UnprocessableContentError("failed to resolve arguments", map[string]any{
				"cause": parseErr.Error(),
			})
		}

		connector_addSpanEvent(span, logger, "execute_function", map[string]any{
			"arguments": args,
		})
		return FunctionStorageObjectTags(ctx, state, &args)

	case "storagePresignedDownloadUrl":

		selection, err := queryFields.AsObject()
		if err != nil {
			return nil, schema.UnprocessableContentError("the selection field type must be object", map[string]any{
				"cause": err.Error(),
			})
		}
		var args common.PresignedGetStorageObjectArguments
		parseErr := args.FromValue(rawArgs)
		if parseErr != nil {
			return nil, schema.UnprocessableContentError("failed to resolve arguments", map[string]any{
				"cause": parseErr.Error(),
			})
		}

		connector_addSpanEvent(span, logger, "execute_function", map[string]any{
			"arguments": args,
		})
		rawResult, err := FunctionStoragePresignedDownloadUrl(ctx, state, &args)

		if err != nil {
			return nil, err
		}

		connector_addSpanEvent(span, logger, "evaluate_response_selection", map[string]any{
			"raw_result": rawResult,
		})
		result, err := utils.EvalNestedColumnObject(selection, rawResult)
		if err != nil {
			return nil, err
		}
		return result, nil

	case "storagePresignedHeadUrl":

		selection, err := queryFields.AsObject()
		if err != nil {
			return nil, schema.UnprocessableContentError("the selection field type must be object", map[string]any{
				"cause": err.Error(),
			})
		}
		var args common.PresignedGetStorageObjectArguments
		parseErr := args.FromValue(rawArgs)
		if parseErr != nil {
			return nil, schema.UnprocessableContentError("failed to resolve arguments", map[string]any{
				"cause": parseErr.Error(),
			})
		}

		connector_addSpanEvent(span, logger, "execute_function", map[string]any{
			"arguments": args,
		})
		rawResult, err := FunctionStoragePresignedHeadUrl(ctx, state, &args)

		if err != nil {
			return nil, err
		}

		connector_addSpanEvent(span, logger, "evaluate_response_selection", map[string]any{
			"raw_result": rawResult,
		})
		result, err := utils.EvalNestedColumnObject(selection, rawResult)
		if err != nil {
			return nil, err
		}
		return result, nil

	case "storagePresignedUploadUrl":

		selection, err := queryFields.AsObject()
		if err != nil {
			return nil, schema.UnprocessableContentError("the selection field type must be object", map[string]any{
				"cause": err.Error(),
			})
		}
		var args common.PresignedPutStorageObjectArguments
		parseErr := args.FromValue(rawArgs)
		if parseErr != nil {
			return nil, schema.UnprocessableContentError("failed to resolve arguments", map[string]any{
				"cause": parseErr.Error(),
			})
		}

		connector_addSpanEvent(span, logger, "execute_function", map[string]any{
			"arguments": args,
		})
		rawResult, err := FunctionStoragePresignedUploadUrl(ctx, state, &args)

		if err != nil {
			return nil, err
		}

		connector_addSpanEvent(span, logger, "evaluate_response_selection", map[string]any{
			"raw_result": rawResult,
		})
		result, err := utils.EvalNestedColumnObject(selection, rawResult)
		if err != nil {
			return nil, err
		}
		return result, nil

	default:
		return nil, utils.ErrHandlerNotfound
	}
}

var enumValues_FunctionName = []string{"downloadStorageObject", "downloadStorageObjectText", "storageBucketEncryption", "storageBucketExists", "storageBucketLifecycle", "storageBucketNotification", "storageBucketPolicy", "storageBucketReplication", "storageBucketTags", "storageBucketVersioning", "storageBuckets", "storageIncompleteUploads", "storageObject", "storageObjectAttributes", "storageObjectLegalHold", "storageObjectLockConfig", "storageObjectTags", "storagePresignedDownloadUrl", "storagePresignedHeadUrl", "storagePresignedUploadUrl"}

// MutationExists check if the mutation name exists
func (dch DataConnectorHandler) MutationExists(name string) bool {
	return slices.Contains(enumValues_ProcedureName, name)
}
func (dch DataConnectorHandler) Mutation(ctx context.Context, state *types.State, operation *schema.MutationOperation) (schema.MutationOperationResults, error) {
	span := trace.SpanFromContext(ctx)
	logger := connector.GetLogger(ctx)
	ctx = context.WithValue(ctx, utils.CommandSelectionFieldKey, operation.Fields)
	connector_addSpanEvent(span, logger, "validate_request", map[string]any{
		"operations_name": operation.Name,
	})

	switch operation.Name {
	case "composeStorageObject":

		selection, err := operation.Fields.AsObject()
		if err != nil {
			return nil, schema.UnprocessableContentError("the selection field type must be object", map[string]any{
				"cause": err.Error(),
			})
		}
		var args common.ComposeStorageObjectArguments
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		rawResult, err := ProcedureComposeStorageObject(ctx, state, &args)

		if err != nil {
			return nil, err
		}

		connector_addSpanEvent(span, logger, "evaluate_response_selection", map[string]any{
			"raw_result": rawResult,
		})
		result, err := utils.EvalNestedColumnObject(selection, rawResult)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "copyStorageObject":

		selection, err := operation.Fields.AsObject()
		if err != nil {
			return nil, schema.UnprocessableContentError("the selection field type must be object", map[string]any{
				"cause": err.Error(),
			})
		}
		var args common.CopyStorageObjectArguments
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		rawResult, err := ProcedureCopyStorageObject(ctx, state, &args)

		if err != nil {
			return nil, err
		}

		connector_addSpanEvent(span, logger, "evaluate_response_selection", map[string]any{
			"raw_result": rawResult,
		})
		result, err := utils.EvalNestedColumnObject(selection, rawResult)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "createStorageBucket":

		if len(operation.Fields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.MakeStorageBucketOptions
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		result, err := ProcedureCreateStorageBucket(ctx, state, &args)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "enableStorageBucketVersioning":

		if len(operation.Fields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.StorageBucketArguments
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		result, err := ProcedureEnableStorageBucketVersioning(ctx, state, &args)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "putStorageObjectLegalHold":

		if len(operation.Fields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.PutStorageObjectLegalHoldOptions
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		result, err := ProcedurePutStorageObjectLegalHold(ctx, state, &args)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "putStorageObjectRetention":

		if len(operation.Fields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.PutStorageObjectRetentionOptions
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		result, err := ProcedurePutStorageObjectRetention(ctx, state, &args)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "putStorageObjectTags":

		if len(operation.Fields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.PutStorageObjectTaggingOptions
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		result, err := ProcedurePutStorageObjectTags(ctx, state, &args)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "removeIncompleteStorageUpload":

		if len(operation.Fields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.RemoveIncompleteUploadArguments
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		result, err := ProcedureRemoveIncompleteStorageUpload(ctx, state, &args)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "removeStorageBucket":

		if len(operation.Fields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.StorageBucketArguments
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		result, err := ProcedureRemoveStorageBucket(ctx, state, &args)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "removeStorageBucketReplication":

		if len(operation.Fields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.StorageBucketArguments
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		result, err := ProcedureRemoveStorageBucketReplication(ctx, state, &args)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "removeStorageBucketTags":

		if len(operation.Fields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.StorageBucketArguments
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		result, err := ProcedureRemoveStorageBucketTags(ctx, state, &args)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "removeStorageObject":

		if len(operation.Fields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.RemoveStorageObjectOptions
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		result, err := ProcedureRemoveStorageObject(ctx, state, &args)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "removeStorageObjectTags":

		if len(operation.Fields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.StorageObjectTaggingOptions
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		result, err := ProcedureRemoveStorageObjectTags(ctx, state, &args)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "removeStorageObjects":

		selection, err := operation.Fields.AsArray()
		if err != nil {
			return nil, schema.UnprocessableContentError("the selection field type must be array", map[string]any{
				"cause": err.Error(),
			})
		}
		var args common.RemoveStorageObjectsOptions
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		rawResult, err := ProcedureRemoveStorageObjects(ctx, state, &args)

		if err != nil {
			return nil, err
		}

		connector_addSpanEvent(span, logger, "evaluate_response_selection", map[string]any{
			"raw_result": rawResult,
		})
		result, err := utils.EvalNestedColumnArrayIntoSlice(selection, rawResult)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "setStorageBucketEncryption":

		if len(operation.Fields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.SetStorageBucketEncryptionArguments
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		result, err := ProcedureSetStorageBucketEncryption(ctx, state, &args)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "setStorageBucketLifecycle":

		if len(operation.Fields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.SetStorageBucketLifecycleArguments
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		result, err := ProcedureSetStorageBucketLifecycle(ctx, state, &args)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "setStorageBucketNotification":

		if len(operation.Fields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.SetBucketNotificationArguments
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		result, err := ProcedureSetStorageBucketNotification(ctx, state, &args)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "setStorageBucketReplication":

		if len(operation.Fields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.SetStorageBucketReplicationArguments
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		result, err := ProcedureSetStorageBucketReplication(ctx, state, &args)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "setStorageBucketTags":

		if len(operation.Fields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.SetStorageBucketTaggingArguments
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		result, err := ProcedureSetStorageBucketTags(ctx, state, &args)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "setStorageObjectLockConfig":

		if len(operation.Fields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.SetStorageObjectLockArguments
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		result, err := ProcedureSetStorageObjectLockConfig(ctx, state, &args)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "suspendStorageBucketVersioning":

		if len(operation.Fields) > 0 {
			return nil, schema.UnprocessableContentError("cannot evaluate selection fields for scalar", nil)
		}
		var args common.StorageBucketArguments
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		result, err := ProcedureSuspendStorageBucketVersioning(ctx, state, &args)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "uploadStorageObject":

		selection, err := operation.Fields.AsObject()
		if err != nil {
			return nil, schema.UnprocessableContentError("the selection field type must be object", map[string]any{
				"cause": err.Error(),
			})
		}
		var args PutStorageObjectBase64Arguments
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		rawResult, err := ProcedureUploadStorageObject(ctx, state, &args)

		if err != nil {
			return nil, err
		}

		connector_addSpanEvent(span, logger, "evaluate_response_selection", map[string]any{
			"raw_result": rawResult,
		})
		result, err := utils.EvalNestedColumnObject(selection, rawResult)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	case "uploadStorageObjectText":

		selection, err := operation.Fields.AsObject()
		if err != nil {
			return nil, schema.UnprocessableContentError("the selection field type must be object", map[string]any{
				"cause": err.Error(),
			})
		}
		var args PutStorageObjectTextArguments
		if err := json.Unmarshal(operation.Arguments, &args); err != nil {
			return nil, schema.UnprocessableContentError("failed to decode arguments", map[string]any{
				"cause": err.Error(),
			})
		}
		span.AddEvent("execute_procedure")
		rawResult, err := ProcedureUploadStorageObjectText(ctx, state, &args)

		if err != nil {
			return nil, err
		}

		connector_addSpanEvent(span, logger, "evaluate_response_selection", map[string]any{
			"raw_result": rawResult,
		})
		result, err := utils.EvalNestedColumnObject(selection, rawResult)

		if err != nil {
			return nil, err
		}
		return schema.NewProcedureResult(result).Encode(), nil

	default:
		return nil, utils.ErrHandlerNotfound
	}
}

var enumValues_ProcedureName = []string{"composeStorageObject", "copyStorageObject", "createStorageBucket", "enableStorageBucketVersioning", "putStorageObjectLegalHold", "putStorageObjectRetention", "putStorageObjectTags", "removeIncompleteStorageUpload", "removeStorageBucket", "removeStorageBucketReplication", "removeStorageBucketTags", "removeStorageObject", "removeStorageObjectTags", "removeStorageObjects", "setStorageBucketEncryption", "setStorageBucketLifecycle", "setStorageBucketNotification", "setStorageBucketReplication", "setStorageBucketTags", "setStorageObjectLockConfig", "suspendStorageBucketVersioning", "uploadStorageObject", "uploadStorageObjectText"}

func connector_addSpanEvent(span trace.Span, logger *slog.Logger, name string, data map[string]any, options ...trace.EventOption) {
	logger.Debug(name, slog.Any("data", data))
	attrs := utils.DebugJSONAttributes(data, utils.IsDebug(logger))
	span.AddEvent(name, append(options, trace.WithAttributes(attrs...))...)
}
