// Code generated by github.com/hasura/ndc-sdk-go/cmd/hasura-ndc-go, DO NOT EDIT.
package common

import (
	"encoding/json"
	"errors"
	"github.com/hasura/ndc-sdk-go/scalar"
	"github.com/hasura/ndc-sdk-go/schema"
	"github.com/hasura/ndc-sdk-go/utils"
	"slices"
)

// FromValue decodes values from map
func (j *GetStorageBucketArguments) FromValue(input map[string]any) error {
	var err error
	j.StorageClientCredentialArguments, err = utils.DecodeObject[StorageClientCredentialArguments](input)
	if err != nil {
		return err
	}
	j.Name, err = utils.GetString(input, "name")
	if err != nil {
		return err
	}
	j.Where, err = utils.DecodeObjectValueDefault[schema.Expression](input, "where")
	if err != nil {
		return err
	}
	return nil
}

// FromValue decodes values from map
func (j *GetStorageObjectArguments) FromValue(input map[string]any) error {
	var err error
	j.GetStorageObjectOptions, err = utils.DecodeObject[GetStorageObjectOptions](input)
	if err != nil {
		return err
	}
	j.StorageBucketArguments, err = utils.DecodeObject[StorageBucketArguments](input)
	if err != nil {
		return err
	}
	j.Name, err = utils.GetString(input, "name")
	if err != nil {
		return err
	}
	j.Where, err = utils.DecodeObjectValueDefault[schema.Expression](input, "where")
	if err != nil {
		return err
	}
	return nil
}

// FromValue decodes values from map
func (j *GetStorageObjectOptions) FromValue(input map[string]any) error {
	var err error
	j.Headers, err = utils.DecodeObjectValueDefault[[]StorageKeyValue](input, "headers")
	if err != nil {
		return err
	}
	j.PartNumber, err = utils.GetNullableInt[int](input, "part_number")
	if err != nil {
		return err
	}
	j.RequestParams, err = utils.DecodeObjectValueDefault[[]StorageKeyValue](input, "request_params")
	if err != nil {
		return err
	}
	j.VersionID, err = utils.GetNullableString(input, "version_id")
	if err != nil {
		return err
	}
	return nil
}

// FromValue decodes values from map
func (j *ListIncompleteUploadsArguments) FromValue(input map[string]any) error {
	var err error
	j.ListIncompleteUploadsOptions, err = utils.DecodeObject[ListIncompleteUploadsOptions](input)
	if err != nil {
		return err
	}
	j.StorageBucketArguments, err = utils.DecodeObject[StorageBucketArguments](input)
	if err != nil {
		return err
	}
	return nil
}

// FromValue decodes values from map
func (j *ListIncompleteUploadsOptions) FromValue(input map[string]any) error {
	var err error
	j.Prefix, err = utils.GetStringDefault(input, "prefix")
	if err != nil {
		return err
	}
	return nil
}

// FromValue decodes values from map
func (j *ListStorageBucketArguments) FromValue(input map[string]any) error {
	var err error
	j.StorageClientCredentialArguments, err = utils.DecodeObject[StorageClientCredentialArguments](input)
	if err != nil {
		return err
	}
	j.After, err = utils.GetStringDefault(input, "after")
	if err != nil {
		return err
	}
	j.First, err = utils.GetNullableInt[int](input, "first")
	if err != nil {
		return err
	}
	j.Prefix, err = utils.GetStringDefault(input, "prefix")
	if err != nil {
		return err
	}
	j.Where, err = utils.DecodeObjectValueDefault[schema.Expression](input, "where")
	if err != nil {
		return err
	}
	return nil
}

// FromValue decodes values from map
func (j *ListStorageObjectsArguments) FromValue(input map[string]any) error {
	var err error
	j.StorageBucketArguments, err = utils.DecodeObject[StorageBucketArguments](input)
	if err != nil {
		return err
	}
	j.After, err = utils.GetNullableString(input, "after")
	if err != nil {
		return err
	}
	j.First, err = utils.GetNullableInt[int](input, "first")
	if err != nil {
		return err
	}
	j.Prefix, err = utils.GetStringDefault(input, "prefix")
	if err != nil {
		return err
	}
	j.Recursive, err = utils.GetBooleanDefault(input, "recursive")
	if err != nil {
		return err
	}
	j.Where, err = utils.DecodeObjectValueDefault[schema.Expression](input, "where")
	if err != nil {
		return err
	}
	return nil
}

// FromValue decodes values from map
func (j *PresignedGetStorageObjectArguments) FromValue(input map[string]any) error {
	var err error
	j.PresignedGetStorageObjectOptions, err = utils.DecodeObject[PresignedGetStorageObjectOptions](input)
	if err != nil {
		return err
	}
	j.StorageBucketArguments, err = utils.DecodeObject[StorageBucketArguments](input)
	if err != nil {
		return err
	}
	j.Name, err = utils.GetString(input, "name")
	if err != nil {
		return err
	}
	j.Where, err = utils.DecodeObjectValueDefault[schema.Expression](input, "where")
	if err != nil {
		return err
	}
	return nil
}

// FromValue decodes values from map
func (j *PresignedGetStorageObjectOptions) FromValue(input map[string]any) error {
	var err error
	j.Expiry, err = utils.DecodeNullableObjectValue[scalar.DurationString](input, "expiry")
	if err != nil {
		return err
	}
	j.RequestParams, err = utils.DecodeObjectValueDefault[[]StorageKeyValue](input, "request_params")
	if err != nil {
		return err
	}
	return nil
}

// FromValue decodes values from map
func (j *PresignedPutStorageObjectArguments) FromValue(input map[string]any) error {
	var err error
	j.StorageBucketArguments, err = utils.DecodeObject[StorageBucketArguments](input)
	if err != nil {
		return err
	}
	j.Expiry, err = utils.DecodeNullableObjectValue[scalar.DurationString](input, "expiry")
	if err != nil {
		return err
	}
	j.Name, err = utils.GetString(input, "name")
	if err != nil {
		return err
	}
	j.Where, err = utils.DecodeObjectValueDefault[schema.Expression](input, "where")
	if err != nil {
		return err
	}
	return nil
}

// FromValue decodes values from map
func (j *StorageBucketArguments) FromValue(input map[string]any) error {
	var err error
	j.StorageClientCredentialArguments, err = utils.DecodeObject[StorageClientCredentialArguments](input)
	if err != nil {
		return err
	}
	j.Bucket, err = utils.GetStringDefault(input, "bucket")
	if err != nil {
		return err
	}
	return nil
}

// FromValue decodes values from map
func (j *StorageClientCredentialArguments) FromValue(input map[string]any) error {
	var err error
	j.AccessKeyID, err = utils.GetStringDefault(input, "access_key_id")
	if err != nil {
		return err
	}
	j.ClientID, err = utils.DecodeNullableObjectValue[StorageClientID](input, "client_id")
	if err != nil {
		return err
	}
	j.ClientType, err = utils.DecodeNullableObjectValue[StorageProviderType](input, "client_type")
	if err != nil {
		return err
	}
	j.Endpoint, err = utils.GetStringDefault(input, "endpoint")
	if err != nil {
		return err
	}
	j.SecretAccessKey, err = utils.GetStringDefault(input, "secret_access_key")
	if err != nil {
		return err
	}
	return nil
}

// FromValue decodes values from map
func (j *StorageKeyValue) FromValue(input map[string]any) error {
	var err error
	j.Key, err = utils.GetString(input, "key")
	if err != nil {
		return err
	}
	j.Value, err = utils.GetString(input, "value")
	if err != nil {
		return err
	}
	return nil
}

// ToMap encodes the struct to a value map
func (j BucketAutoclass) ToMap() map[string]any {
	r := make(map[string]any)
	r["enabled"] = j.Enabled
	r["terminal_storage_class"] = j.TerminalStorageClass
	r["terminal_storage_class_update_time"] = j.TerminalStorageClassUpdateTime
	r["toggle_time"] = j.ToggleTime

	return r
}

// ToMap encodes the struct to a value map
func (j BucketCors) ToMap() map[string]any {
	r := make(map[string]any)
	r["max_age"] = j.MaxAge
	r["methods"] = j.Methods
	r["origins"] = j.Origins
	r["response_headers"] = j.ResponseHeaders

	return r
}

// ToMap encodes the struct to a value map
func (j BucketHierarchicalNamespace) ToMap() map[string]any {
	r := make(map[string]any)
	r["enabled"] = j.Enabled

	return r
}

// ToMap encodes the struct to a value map
func (j BucketLogging) ToMap() map[string]any {
	r := make(map[string]any)
	r["log_bucket"] = j.LogBucket
	r["log_object_prefix"] = j.LogObjectPrefix

	return r
}

// ToMap encodes the struct to a value map
func (j BucketWebsite) ToMap() map[string]any {
	r := make(map[string]any)
	r["main_page_suffix"] = j.MainPageSuffix
	r["not_found_page"] = j.NotFoundPage

	return r
}

// ToMap encodes the struct to a value map
func (j CustomPlacementConfig) ToMap() map[string]any {
	r := make(map[string]any)
	r["data_locations"] = j.DataLocations

	return r
}

// ToMap encodes the struct to a value map
func (j GetStorageBucketArguments) ToMap() map[string]any {
	r := make(map[string]any)
	r = utils.MergeMap(r, j.StorageClientCredentialArguments.ToMap())
	r["name"] = j.Name
	if j.Where != nil {
		r["where"] = j.Where
	}

	return r
}

// ToMap encodes the struct to a value map
func (j GetStorageObjectOptions) ToMap() map[string]any {
	r := make(map[string]any)
	j_Headers := make([]any, len(j.Headers))
	for i, j_Headers_v := range j.Headers {
		j_Headers[i] = j_Headers_v
	}
	r["headers"] = j_Headers
	r["part_number"] = j.PartNumber
	j_RequestParams := make([]any, len(j.RequestParams))
	for i, j_RequestParams_v := range j.RequestParams {
		j_RequestParams[i] = j_RequestParams_v
	}
	r["request_params"] = j_RequestParams
	r["version_id"] = j.VersionID

	return r
}

// ToMap encodes the struct to a value map
func (j HTTPRequestOptions) ToMap() map[string]any {
	r := make(map[string]any)
	r["body_text"] = j.BodyText
	j_Headers := make([]any, len(j.Headers))
	for i, j_Headers_v := range j.Headers {
		j_Headers[i] = j_Headers_v
	}
	r["headers"] = j_Headers
	r["method"] = j.Method
	r["url"] = j.URL

	return r
}

// ToMap encodes the struct to a value map
func (j ListIncompleteUploadsOptions) ToMap() map[string]any {
	r := make(map[string]any)
	r["prefix"] = j.Prefix

	return r
}

// ToMap encodes the struct to a value map
func (j ListStorageObjectsArguments) ToMap() map[string]any {
	r := make(map[string]any)
	r = utils.MergeMap(r, j.StorageBucketArguments.ToMap())
	r["after"] = j.After
	r["first"] = j.First
	r["prefix"] = j.Prefix
	r["recursive"] = j.Recursive
	if j.Where != nil {
		r["where"] = j.Where
	}

	return r
}

// ToMap encodes the struct to a value map
func (j MakeStorageBucketOptions) ToMap() map[string]any {
	r := make(map[string]any)
	r["name"] = j.Name
	r["object_lock"] = j.ObjectLock
	r["region"] = j.Region
	j_Tags := make([]any, len(j.Tags))
	for i, j_Tags_v := range j.Tags {
		j_Tags[i] = j_Tags_v
	}
	r["tags"] = j_Tags

	return r
}

// ToMap encodes the struct to a value map
func (j ObjectAbortIncompleteMultipartUpload) ToMap() map[string]any {
	r := make(map[string]any)
	r["days_after_initiation"] = j.DaysAfterInitiation

	return r
}

// ToMap encodes the struct to a value map
func (j ObjectLifecycleAllVersionsExpiration) ToMap() map[string]any {
	r := make(map[string]any)
	r["days"] = j.Days
	r["delete_marker"] = j.DeleteMarker

	return r
}

// ToMap encodes the struct to a value map
func (j ObjectLifecycleConfiguration) ToMap() map[string]any {
	r := make(map[string]any)
	j_Rules := make([]any, len(j.Rules))
	for i, j_Rules_v := range j.Rules {
		j_Rules[i] = j_Rules_v
	}
	r["rules"] = j_Rules

	return r
}

// ToMap encodes the struct to a value map
func (j ObjectLifecycleDelMarkerExpiration) ToMap() map[string]any {
	r := make(map[string]any)
	r["days"] = j.Days

	return r
}

// ToMap encodes the struct to a value map
func (j ObjectLifecycleExpiration) ToMap() map[string]any {
	r := make(map[string]any)
	r["date"] = j.Date
	r["days"] = j.Days
	r["expired_object_all_versions"] = j.DeleteAll
	r["expired_object_delete_marker"] = j.DeleteMarker

	return r
}

// ToMap encodes the struct to a value map
func (j ObjectLifecycleFilter) ToMap() map[string]any {
	r := make(map[string]any)
	r["matches_prefix"] = j.MatchesPrefix
	r["matches_storage_classes"] = j.MatchesStorageClasses
	r["matches_suffix"] = j.MatchesSuffix
	r["object_size_greater_than"] = j.ObjectSizeGreaterThan
	r["object_size_less_than"] = j.ObjectSizeLessThan
	j_Tags := make([]any, len(j.Tags))
	for i, j_Tags_v := range j.Tags {
		j_Tags[i] = j_Tags_v
	}
	r["tags"] = j_Tags

	return r
}

// ToMap encodes the struct to a value map
func (j ObjectLifecycleNoncurrentVersionExpiration) ToMap() map[string]any {
	r := make(map[string]any)
	r["newer_noncurrent_versions"] = j.NewerNoncurrentVersions
	r["noncurrent_days"] = j.NoncurrentDays

	return r
}

// ToMap encodes the struct to a value map
func (j ObjectLifecycleNoncurrentVersionTransition) ToMap() map[string]any {
	r := make(map[string]any)
	r["newer_noncurrent_versions"] = j.NewerNoncurrentVersions
	r["noncurrent_days"] = j.NoncurrentDays
	r["storage_class"] = j.StorageClass

	return r
}

// ToMap encodes the struct to a value map
func (j ObjectLifecycleRule) ToMap() map[string]any {
	r := make(map[string]any)
	if j.AbortIncompleteMultipartUpload != nil {
		r["abort_incomplete_multipart_upload"] = (*j.AbortIncompleteMultipartUpload)
	}
	if j.AllVersionsExpiration != nil {
		r["all_versions_expiration"] = (*j.AllVersionsExpiration)
	}
	if j.DelMarkerExpiration != nil {
		r["del_marker_expiration"] = (*j.DelMarkerExpiration)
	}
	r["enabled"] = j.Enabled
	if j.Expiration != nil {
		r["expiration"] = (*j.Expiration)
	}
	j_RuleFilter := make([]any, len(j.RuleFilter))
	for i, j_RuleFilter_v := range j.RuleFilter {
		j_RuleFilter[i] = j_RuleFilter_v
	}
	r["filter"] = j_RuleFilter
	r["id"] = j.ID
	if j.NoncurrentVersionExpiration != nil {
		r["noncurrent_version_expiration"] = (*j.NoncurrentVersionExpiration)
	}
	if j.NoncurrentVersionTransition != nil {
		r["noncurrent_version_transition"] = (*j.NoncurrentVersionTransition)
	}
	r["prefix"] = j.Prefix
	if j.Transition != nil {
		r["transition"] = (*j.Transition)
	}

	return r
}

// ToMap encodes the struct to a value map
func (j ObjectLifecycleTransition) ToMap() map[string]any {
	r := make(map[string]any)
	r["date"] = j.Date
	r["days"] = j.Days
	r["storage_class"] = j.StorageClass

	return r
}

// ToMap encodes the struct to a value map
func (j PresignedGetStorageObjectOptions) ToMap() map[string]any {
	r := make(map[string]any)
	r["expiry"] = j.Expiry
	j_RequestParams := make([]any, len(j.RequestParams))
	for i, j_RequestParams_v := range j.RequestParams {
		j_RequestParams[i] = j_RequestParams_v
	}
	r["request_params"] = j_RequestParams

	return r
}

// ToMap encodes the struct to a value map
func (j PresignedURLResponse) ToMap() map[string]any {
	r := make(map[string]any)
	r["expired_at"] = j.ExpiredAt
	r["url"] = j.URL

	return r
}

// ToMap encodes the struct to a value map
func (j PutStorageObjectArguments) ToMap() map[string]any {
	r := make(map[string]any)
	r = utils.MergeMap(r, j.StorageBucketArguments.ToMap())
	r["name"] = j.Name
	r["options"] = j.Options
	if j.Where != nil {
		r["where"] = j.Where
	}

	return r
}

// ToMap encodes the struct to a value map
func (j PutStorageObjectOptions) ToMap() map[string]any {
	r := make(map[string]any)
	r["auto_checksum"] = j.AutoChecksum
	r["cache_control"] = j.CacheControl
	r["checksum"] = j.Checksum
	r["concurrent_stream_parts"] = j.ConcurrentStreamParts
	r["content_disposition"] = j.ContentDisposition
	r["content_encoding"] = j.ContentEncoding
	r["content_language"] = j.ContentLanguage
	r["content_type"] = j.ContentType
	r["disable_content_sha256"] = j.DisableContentSha256
	r["disable_multipart"] = j.DisableMultipart
	r["expires"] = j.Expires
	r["legal_hold"] = j.LegalHold
	j_Metadata := make([]any, len(j.Metadata))
	for i, j_Metadata_v := range j.Metadata {
		j_Metadata[i] = j_Metadata_v
	}
	r["metadata"] = j_Metadata
	r["num_threads"] = j.NumThreads
	r["part_size"] = j.PartSize
	if j.Retention != nil {
		r["retention"] = (*j.Retention)
	}
	r["send_content_md5"] = j.SendContentMd5
	r["storage_class"] = j.StorageClass
	j_Tags := make([]any, len(j.Tags))
	for i, j_Tags_v := range j.Tags {
		j_Tags[i] = j_Tags_v
	}
	r["tags"] = j_Tags
	r["website_redirect_location"] = j.WebsiteRedirectLocation

	return r
}

// ToMap encodes the struct to a value map
func (j PutStorageObjectRetentionOptions) ToMap() map[string]any {
	r := make(map[string]any)
	r["governance_bypass"] = j.GovernanceBypass
	r["mode"] = j.Mode
	r["retain_until_date"] = j.RetainUntilDate

	return r
}

// ToMap encodes the struct to a value map
func (j RemoveStorageObjectError) ToMap() map[string]any {
	r := make(map[string]any)
	r["error"] = j.Error
	r["object_name"] = j.ObjectName
	r["version_id"] = j.VersionID

	return r
}

// ToMap encodes the struct to a value map
func (j RemoveStorageObjectOptions) ToMap() map[string]any {
	r := make(map[string]any)
	r["force_delete"] = j.ForceDelete
	r["governance_bypass"] = j.GovernanceBypass
	r["soft_delete"] = j.SoftDelete
	r["version_id"] = j.VersionID

	return r
}

// ToMap encodes the struct to a value map
func (j ServerSideEncryptionConfiguration) ToMap() map[string]any {
	r := make(map[string]any)
	r["kms_master_key_id"] = j.KmsMasterKeyID
	r["sse_algorithm"] = j.SSEAlgorithm

	return r
}

// ToMap encodes the struct to a value map
func (j SetStorageObjectLockConfig) ToMap() map[string]any {
	r := make(map[string]any)
	r["mode"] = j.Mode
	r["unit"] = j.Unit
	r["validity"] = j.Validity

	return r
}

// ToMap encodes the struct to a value map
func (j SetStorageObjectRetentionOptions) ToMap() map[string]any {
	r := make(map[string]any)
	r["governance_bypass"] = j.GovernanceBypass
	r["mode"] = j.Mode
	r["retain_until_date"] = j.RetainUntilDate

	return r
}

// ToMap encodes the struct to a value map
func (j StorageBucket) ToMap() map[string]any {
	r := make(map[string]any)
	if j.Autoclass != nil {
		r["autoclass"] = (*j.Autoclass)
	}
	r["client_id"] = j.ClientID
	j_CORS := make([]any, len(j.CORS))
	for i, j_CORS_v := range j.CORS {
		j_CORS[i] = j_CORS_v
	}
	r["cors"] = j_CORS
	r["creation_time"] = j.CreationTime
	if j.CustomPlacementConfig != nil {
		r["custom_placement_config"] = (*j.CustomPlacementConfig)
	}
	r["default_event_based_hold"] = j.DefaultEventBasedHold
	if j.Encryption != nil {
		r["encryption"] = (*j.Encryption)
	}
	r["etag"] = j.Etag
	if j.HierarchicalNamespace != nil {
		r["hierarchical_namespace"] = (*j.HierarchicalNamespace)
	}
	r["last_modified"] = j.LastModified
	if j.Lifecycle != nil {
		r["lifecycle"] = (*j.Lifecycle)
	}
	r["location_type"] = j.LocationType
	if j.Logging != nil {
		r["logging"] = (*j.Logging)
	}
	r["name"] = j.Name
	if j.ObjectLock != nil {
		r["object_lock"] = (*j.ObjectLock)
	}
	r["region"] = j.Region
	r["requester_pays"] = j.RequesterPays
	r["rpo"] = j.RPO
	if j.SoftDeletePolicy != nil {
		r["soft_delete_policy"] = (*j.SoftDeletePolicy)
	}
	r["storage_class"] = j.StorageClass
	j_Tags := make([]any, len(j.Tags))
	for i, j_Tags_v := range j.Tags {
		j_Tags[i] = j_Tags_v
	}
	r["tags"] = j_Tags
	if j.Versioning != nil {
		r["versioning"] = (*j.Versioning)
	}
	if j.Website != nil {
		r["website"] = (*j.Website)
	}

	return r
}

// ToMap encodes the struct to a value map
func (j StorageBucketArguments) ToMap() map[string]any {
	r := make(map[string]any)
	r = utils.MergeMap(r, j.StorageClientCredentialArguments.ToMap())
	r["bucket"] = j.Bucket

	return r
}

// ToMap encodes the struct to a value map
func (j StorageBucketVersioningConfiguration) ToMap() map[string]any {
	r := make(map[string]any)
	r["enabled"] = j.Enabled
	r["exclude_folders"] = j.ExcludeFolders
	r["excluded_prefixes"] = j.ExcludedPrefixes
	r["mfa_delete"] = j.MFADelete

	return r
}

// ToMap encodes the struct to a value map
func (j StorageClientCredentialArguments) ToMap() map[string]any {
	r := make(map[string]any)
	r["access_key_id"] = j.AccessKeyID
	r["client_id"] = j.ClientID
	r["client_type"] = j.ClientType
	r["endpoint"] = j.Endpoint
	r["secret_access_key"] = j.SecretAccessKey

	return r
}

// ToMap encodes the struct to a value map
func (j StorageCopyDestOptions) ToMap() map[string]any {
	r := make(map[string]any)
	r["bucket"] = j.Bucket
	r["legal_hold"] = j.LegalHold
	j_Metadata := make([]any, len(j.Metadata))
	for i, j_Metadata_v := range j.Metadata {
		j_Metadata[i] = j_Metadata_v
	}
	r["metadata"] = j_Metadata
	r["mode"] = j.Mode
	r["name"] = j.Name
	r["retain_until_date"] = j.RetainUntilDate
	r["size"] = j.Size
	j_Tags := make([]any, len(j.Tags))
	for i, j_Tags_v := range j.Tags {
		j_Tags[i] = j_Tags_v
	}
	r["tags"] = j_Tags

	return r
}

// ToMap encodes the struct to a value map
func (j StorageCopySrcOptions) ToMap() map[string]any {
	r := make(map[string]any)
	r["bucket"] = j.Bucket
	r["end"] = j.End
	r["match_etag"] = j.MatchETag
	r["match_modified_since"] = j.MatchModifiedSince
	r["match_range"] = j.MatchRange
	r["match_unmodified_since"] = j.MatchUnmodifiedSince
	r["name"] = j.Name
	r["no_match_etag"] = j.NoMatchETag
	r["start"] = j.Start
	r["version_id"] = j.VersionID

	return r
}

// ToMap encodes the struct to a value map
func (j StorageGrant) ToMap() map[string]any {
	r := make(map[string]any)
	if j.Grantee != nil {
		r["grantee"] = (*j.Grantee)
	}
	r["permission"] = j.Permission

	return r
}

// ToMap encodes the struct to a value map
func (j StorageGrantee) ToMap() map[string]any {
	r := make(map[string]any)
	r["display_name"] = j.DisplayName
	r["id"] = j.ID
	r["uri"] = j.URI

	return r
}

// ToMap encodes the struct to a value map
func (j StorageKeyValue) ToMap() map[string]any {
	r := make(map[string]any)
	r["key"] = j.Key
	r["value"] = j.Value

	return r
}

// ToMap encodes the struct to a value map
func (j StorageObject) ToMap() map[string]any {
	r := make(map[string]any)
	r = utils.MergeMap(r, j.StorageObjectChecksum.ToMap())
	r["access_tier_change_time"] = j.AccessTierChangeTime
	r["access_tier_inferred"] = j.AccessTierInferred
	r["acl"] = j.ACL
	r["archive_status"] = j.ArchiveStatus
	r["blob_sequence_number"] = j.BlobSequenceNumber
	r["blob_type"] = j.BlobType
	r["bucket"] = j.Bucket
	r["cache_control"] = j.CacheControl
	r["client_id"] = j.ClientID
	r["content_disposition"] = j.ContentDisposition
	r["content_encoding"] = j.ContentEncoding
	r["content_language"] = j.ContentLanguage
	r["content_md5"] = j.ContentMD5
	r["content_type"] = j.ContentType
	if j.Copy != nil {
		r["copy"] = (*j.Copy)
	}
	r["creation_time"] = j.CreationTime
	r["customer_provided_key_sha256"] = j.CustomerProvidedKeySHA256
	r["deleted"] = j.Deleted
	r["deleted_time"] = j.DeletedTime
	r["destination_snapshot"] = j.DestinationSnapshot
	r["etag"] = j.ETag
	r["expiration"] = j.Expiration
	r["expiration_rule_id"] = j.ExpirationRuleID
	r["expires"] = j.Expires
	j_Grant := make([]any, len(j.Grant))
	for i, j_Grant_v := range j.Grant {
		j_Grant[i] = j_Grant_v
	}
	r["grant"] = j_Grant
	r["group"] = j.Group
	r["incremental_copy"] = j.IncrementalCopy
	r["is_directory"] = j.IsDirectory
	r["is_latest"] = j.IsLatest
	r["kms_key_name"] = j.KMSKeyName
	r["last_access_time"] = j.LastAccessTime
	r["last_modified"] = j.LastModified
	r["lease_duration"] = j.LeaseDuration
	r["lease_state"] = j.LeaseState
	r["lease_status"] = j.LeaseStatus
	r["legal_hold"] = j.LegalHold
	r["media_link"] = j.MediaLink
	j_Metadata := make([]any, len(j.Metadata))
	for i, j_Metadata_v := range j.Metadata {
		j_Metadata[i] = j_Metadata_v
	}
	r["metadata"] = j_Metadata
	r["name"] = j.Name
	if j.Owner != nil {
		r["owner"] = (*j.Owner)
	}
	r["permissions"] = j.Permissions
	j_RawMetadata := make([]any, len(j.RawMetadata))
	for i, j_RawMetadata_v := range j.RawMetadata {
		j_RawMetadata[i] = j_RawMetadata_v
	}
	r["raw_metadata"] = j_RawMetadata
	r["rehydrate_priority"] = j.RehydratePriority
	r["remaining_retention_days"] = j.RemainingRetentionDays
	r["replication_ready"] = j.ReplicationReady
	r["replication_status"] = j.ReplicationStatus
	r["resource_type"] = j.ResourceType
	if j.Restore != nil {
		r["restore"] = (*j.Restore)
	}
	r["retention_mode"] = j.RetentionMode
	r["retention_until_date"] = j.RetentionUntilDate
	r["sealed"] = j.IsSealed
	r["server_encrypted"] = j.ServerEncrypted
	r["size"] = j.Size
	r["storage_class"] = j.StorageClass
	r["tag_count"] = j.TagCount
	j_Tags := make([]any, len(j.Tags))
	for i, j_Tags_v := range j.Tags {
		j_Tags[i] = j_Tags_v
	}
	r["tags"] = j_Tags
	r["version_id"] = j.VersionID

	return r
}

// ToMap encodes the struct to a value map
func (j StorageObjectChecksum) ToMap() map[string]any {
	r := make(map[string]any)
	r["checksum_crc32"] = j.ChecksumCRC32
	r["checksum_crc32c"] = j.ChecksumCRC32C
	r["checksum_crc64_nvme"] = j.ChecksumCRC64NVME
	r["checksum_sha1"] = j.ChecksumSHA1
	r["checksum_sha256"] = j.ChecksumSHA256

	return r
}

// ToMap encodes the struct to a value map
func (j StorageObjectCopyInfo) ToMap() map[string]any {
	r := make(map[string]any)
	r["completion_time"] = j.CompletionTime
	r["id"] = j.ID
	r["progress"] = j.Progress
	r["source"] = j.Source
	r["status"] = j.Status
	r["status_description"] = j.StatusDescription

	return r
}

// ToMap encodes the struct to a value map
func (j StorageObjectListResults) ToMap() map[string]any {
	r := make(map[string]any)
	j_Objects := make([]any, len(j.Objects))
	for i, j_Objects_v := range j.Objects {
		j_Objects[i] = j_Objects_v
	}
	r["objects"] = j_Objects
	r["pageInfo"] = j.PageInfo

	return r
}

// ToMap encodes the struct to a value map
func (j StorageObjectLockConfig) ToMap() map[string]any {
	r := make(map[string]any)
	r = utils.MergeMap(r, j.SetStorageObjectLockConfig.ToMap())
	r["enabled"] = j.Enabled

	return r
}

// ToMap encodes the struct to a value map
func (j StorageObjectMultipartInfo) ToMap() map[string]any {
	r := make(map[string]any)
	r["initiated"] = j.Initiated
	r["name"] = j.Name
	r["size"] = j.Size
	r["storage_class"] = j.StorageClass
	r["upload_id"] = j.UploadID

	return r
}

// ToMap encodes the struct to a value map
func (j StorageObjectSoftDeletePolicy) ToMap() map[string]any {
	r := make(map[string]any)
	r["effective_time"] = j.EffectiveTime
	r["retention_duration"] = j.RetentionDuration

	return r
}

// ToMap encodes the struct to a value map
func (j StorageOwner) ToMap() map[string]any {
	r := make(map[string]any)
	r["id"] = j.ID
	r["name"] = j.DisplayName

	return r
}

// ToMap encodes the struct to a value map
func (j StoragePaginationInfo) ToMap() map[string]any {
	r := make(map[string]any)
	r["hasNextPage"] = j.HasNextPage

	return r
}

// ToMap encodes the struct to a value map
func (j StorageRestoreInfo) ToMap() map[string]any {
	r := make(map[string]any)
	r["expiry_time"] = j.ExpiryTime
	r["ongoing_restore"] = j.OngoingRestore

	return r
}

// ToMap encodes the struct to a value map
func (j StorageUploadInfo) ToMap() map[string]any {
	r := make(map[string]any)
	r = utils.MergeMap(r, j.StorageObjectChecksum.ToMap())
	r["bucket"] = j.Bucket
	r["client_id"] = j.ClientID
	r["content_md5"] = j.ContentMD5
	r["etag"] = j.ETag
	r["expiration"] = j.Expiration
	r["expiration_rule_id"] = j.ExpirationRuleID
	r["last_modified"] = j.LastModified
	r["location"] = j.Location
	r["name"] = j.Name
	r["size"] = j.Size
	r["version_id"] = j.VersionID

	return r
}

// ToMap encodes the struct to a value map
func (j UpdateStorageBucketOptions) ToMap() map[string]any {
	r := make(map[string]any)
	if j.Encryption != nil {
		r["encryption"] = (*j.Encryption)
	}
	if j.Lifecycle != nil {
		r["lifecycle"] = (*j.Lifecycle)
	}
	if j.ObjectLock != nil {
		r["object_lock"] = (*j.ObjectLock)
	}
	if j.Tags != nil {
		j_Tags := make([]any, len((*j.Tags)))
		for i, j_Tags_v := range *j.Tags {
			j_Tags[i] = j_Tags_v
		}
		r["tags"] = j_Tags
	}
	r["versioning_enabled"] = j.VersioningEnabled

	return r
}

// ToMap encodes the struct to a value map
func (j UpdateStorageObjectOptions) ToMap() map[string]any {
	r := make(map[string]any)
	r["legal_hold"] = j.LegalHold
	if j.Metadata != nil {
		j_Metadata := make([]any, len((*j.Metadata)))
		for i, j_Metadata_v := range *j.Metadata {
			j_Metadata[i] = j_Metadata_v
		}
		r["metadata"] = j_Metadata
	}
	if j.Retention != nil {
		r["retention"] = (*j.Retention)
	}
	if j.Tags != nil {
		j_Tags := make([]any, len((*j.Tags)))
		for i, j_Tags_v := range *j.Tags {
			j_Tags[i] = j_Tags_v
		}
		r["tags"] = j_Tags
	}
	r["version_id"] = j.VersionID

	return r
}

// ScalarName get the schema name of the scalar
func (j ChecksumType) ScalarName() string {
	return "ChecksumType"
}

const (
	ChecksumTypeSha256           ChecksumType = "SHA256"
	ChecksumTypeSha1             ChecksumType = "SHA1"
	ChecksumTypeCrc32            ChecksumType = "CRC32"
	ChecksumTypeCrc32C           ChecksumType = "CRC32C"
	ChecksumTypeCrc64NVME        ChecksumType = "CRC64NVME"
	ChecksumTypeFullObjectCRC32  ChecksumType = "FullObjectCRC32"
	ChecksumTypeFullObjectCRC32C ChecksumType = "FullObjectCRC32C"
	ChecksumTypeNone             ChecksumType = "None"
)

var enumValues_ChecksumType = []ChecksumType{ChecksumTypeSha256, ChecksumTypeSha1, ChecksumTypeCrc32, ChecksumTypeCrc32C, ChecksumTypeCrc64NVME, ChecksumTypeFullObjectCRC32, ChecksumTypeFullObjectCRC32C, ChecksumTypeNone}

// ParseChecksumType parses a ChecksumType enum from string
func ParseChecksumType(input string) (ChecksumType, error) {
	result := ChecksumType(input)
	if !slices.Contains(enumValues_ChecksumType, result) {
		return ChecksumType(""), errors.New("failed to parse ChecksumType, expect one of [SHA256, SHA1, CRC32, CRC32C, CRC64NVME, FullObjectCRC32, FullObjectCRC32C, None]")
	}

	return result, nil
}

// IsValid checks if the value is invalid
func (j ChecksumType) IsValid() bool {
	return slices.Contains(enumValues_ChecksumType, j)
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChecksumType) UnmarshalJSON(b []byte) error {
	var rawValue string
	if err := json.Unmarshal(b, &rawValue); err != nil {
		return err
	}

	value, err := ParseChecksumType(rawValue)
	if err != nil {
		return err
	}

	*j = value
	return nil
}

// FromValue decodes the scalar from an unknown value
func (s *ChecksumType) FromValue(value any) error {
	valueStr, err := utils.DecodeNullableString(value)
	if err != nil {
		return err
	}
	if valueStr == nil {
		return nil
	}
	result, err := ParseChecksumType(*valueStr)
	if err != nil {
		return err
	}

	*s = result
	return nil
}

// ScalarName get the schema name of the scalar
func (j DownloadHTTPMethod) ScalarName() string {
	return "DownloadHTTPMethod"
}

const (
	DownloadHTTPMethodGet  DownloadHTTPMethod = "GET"
	DownloadHTTPMethodPost DownloadHTTPMethod = "POST"
)

var enumValues_DownloadHTTPMethod = []DownloadHTTPMethod{DownloadHTTPMethodGet, DownloadHTTPMethodPost}

// ParseDownloadHTTPMethod parses a DownloadHTTPMethod enum from string
func ParseDownloadHTTPMethod(input string) (DownloadHTTPMethod, error) {
	result := DownloadHTTPMethod(input)
	if !slices.Contains(enumValues_DownloadHTTPMethod, result) {
		return DownloadHTTPMethod(""), errors.New("failed to parse DownloadHTTPMethod, expect one of [GET, POST]")
	}

	return result, nil
}

// IsValid checks if the value is invalid
func (j DownloadHTTPMethod) IsValid() bool {
	return slices.Contains(enumValues_DownloadHTTPMethod, j)
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DownloadHTTPMethod) UnmarshalJSON(b []byte) error {
	var rawValue string
	if err := json.Unmarshal(b, &rawValue); err != nil {
		return err
	}

	value, err := ParseDownloadHTTPMethod(rawValue)
	if err != nil {
		return err
	}

	*j = value
	return nil
}

// FromValue decodes the scalar from an unknown value
func (s *DownloadHTTPMethod) FromValue(value any) error {
	valueStr, err := utils.DecodeNullableString(value)
	if err != nil {
		return err
	}
	if valueStr == nil {
		return nil
	}
	result, err := ParseDownloadHTTPMethod(*valueStr)
	if err != nil {
		return err
	}

	*s = result
	return nil
}

// ScalarName get the schema name of the scalar
func (j GoogleStorageRPO) ScalarName() string {
	return "GoogleStorageRPO"
}

const (
	GoogleStorageRPODefault    GoogleStorageRPO = "DEFAULT"
	GoogleStorageRPOAsyncTurbo GoogleStorageRPO = "ASYNC_TURBO"
)

var enumValues_GoogleStorageRPO = []GoogleStorageRPO{GoogleStorageRPODefault, GoogleStorageRPOAsyncTurbo}

// ParseGoogleStorageRPO parses a GoogleStorageRPO enum from string
func ParseGoogleStorageRPO(input string) (GoogleStorageRPO, error) {
	result := GoogleStorageRPO(input)
	if !slices.Contains(enumValues_GoogleStorageRPO, result) {
		return GoogleStorageRPO(""), errors.New("failed to parse GoogleStorageRPO, expect one of [DEFAULT, ASYNC_TURBO]")
	}

	return result, nil
}

// IsValid checks if the value is invalid
func (j GoogleStorageRPO) IsValid() bool {
	return slices.Contains(enumValues_GoogleStorageRPO, j)
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GoogleStorageRPO) UnmarshalJSON(b []byte) error {
	var rawValue string
	if err := json.Unmarshal(b, &rawValue); err != nil {
		return err
	}

	value, err := ParseGoogleStorageRPO(rawValue)
	if err != nil {
		return err
	}

	*j = value
	return nil
}

// FromValue decodes the scalar from an unknown value
func (s *GoogleStorageRPO) FromValue(value any) error {
	valueStr, err := utils.DecodeNullableString(value)
	if err != nil {
		return err
	}
	if valueStr == nil {
		return nil
	}
	result, err := ParseGoogleStorageRPO(*valueStr)
	if err != nil {
		return err
	}

	*s = result
	return nil
}

// ScalarName get the schema name of the scalar
func (j StorageClientID) ScalarName() string {
	return "StorageClientID"
}

// ScalarName get the schema name of the scalar
func (j StorageObjectReplicationStatus) ScalarName() string {
	return "StorageObjectReplicationStatus"
}

const (
	StorageObjectReplicationStatusCompleted StorageObjectReplicationStatus = "COMPLETED"
	StorageObjectReplicationStatusPending   StorageObjectReplicationStatus = "PENDING"
	StorageObjectReplicationStatusFailed    StorageObjectReplicationStatus = "FAILED"
	StorageObjectReplicationStatusReplica   StorageObjectReplicationStatus = "REPLICA"
)

var enumValues_StorageObjectReplicationStatus = []StorageObjectReplicationStatus{StorageObjectReplicationStatusCompleted, StorageObjectReplicationStatusPending, StorageObjectReplicationStatusFailed, StorageObjectReplicationStatusReplica}

// ParseStorageObjectReplicationStatus parses a StorageObjectReplicationStatus enum from string
func ParseStorageObjectReplicationStatus(input string) (StorageObjectReplicationStatus, error) {
	result := StorageObjectReplicationStatus(input)
	if !slices.Contains(enumValues_StorageObjectReplicationStatus, result) {
		return StorageObjectReplicationStatus(""), errors.New("failed to parse StorageObjectReplicationStatus, expect one of [COMPLETED, PENDING, FAILED, REPLICA]")
	}

	return result, nil
}

// IsValid checks if the value is invalid
func (j StorageObjectReplicationStatus) IsValid() bool {
	return slices.Contains(enumValues_StorageObjectReplicationStatus, j)
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StorageObjectReplicationStatus) UnmarshalJSON(b []byte) error {
	var rawValue string
	if err := json.Unmarshal(b, &rawValue); err != nil {
		return err
	}

	value, err := ParseStorageObjectReplicationStatus(rawValue)
	if err != nil {
		return err
	}

	*j = value
	return nil
}

// FromValue decodes the scalar from an unknown value
func (s *StorageObjectReplicationStatus) FromValue(value any) error {
	valueStr, err := utils.DecodeNullableString(value)
	if err != nil {
		return err
	}
	if valueStr == nil {
		return nil
	}
	result, err := ParseStorageObjectReplicationStatus(*valueStr)
	if err != nil {
		return err
	}

	*s = result
	return nil
}

// ScalarName get the schema name of the scalar
func (j StorageProviderType) ScalarName() string {
	return "StorageProviderType"
}

const (
	StorageProviderTypeS3     StorageProviderType = "s3"
	StorageProviderTypeGcs    StorageProviderType = "gcs"
	StorageProviderTypeAzblob StorageProviderType = "azblob"
	StorageProviderTypeFs     StorageProviderType = "fs"
)

var enumValues_StorageProviderType = []StorageProviderType{StorageProviderTypeS3, StorageProviderTypeGcs, StorageProviderTypeAzblob, StorageProviderTypeFs}

// ParseStorageProviderType parses a StorageProviderType enum from string
func ParseStorageProviderType(input string) (StorageProviderType, error) {
	result := StorageProviderType(input)
	if !slices.Contains(enumValues_StorageProviderType, result) {
		return StorageProviderType(""), errors.New("failed to parse StorageProviderType, expect one of [s3, gcs, azblob, fs]")
	}

	return result, nil
}

// IsValid checks if the value is invalid
func (j StorageProviderType) IsValid() bool {
	return slices.Contains(enumValues_StorageProviderType, j)
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StorageProviderType) UnmarshalJSON(b []byte) error {
	var rawValue string
	if err := json.Unmarshal(b, &rawValue); err != nil {
		return err
	}

	value, err := ParseStorageProviderType(rawValue)
	if err != nil {
		return err
	}

	*j = value
	return nil
}

// FromValue decodes the scalar from an unknown value
func (s *StorageProviderType) FromValue(value any) error {
	valueStr, err := utils.DecodeNullableString(value)
	if err != nil {
		return err
	}
	if valueStr == nil {
		return nil
	}
	result, err := ParseStorageProviderType(*valueStr)
	if err != nil {
		return err
	}

	*s = result
	return nil
}

// ScalarName get the schema name of the scalar
func (j StorageRetentionMode) ScalarName() string {
	return "StorageRetentionMode"
}

const (
	StorageRetentionModeLocked   StorageRetentionMode = "Locked"
	StorageRetentionModeUnlocked StorageRetentionMode = "Unlocked"
	StorageRetentionModeMutable  StorageRetentionMode = "Mutable"
	StorageRetentionModeDelete   StorageRetentionMode = "Delete"
)

var enumValues_StorageRetentionMode = []StorageRetentionMode{StorageRetentionModeLocked, StorageRetentionModeUnlocked, StorageRetentionModeMutable, StorageRetentionModeDelete}

// ParseStorageRetentionMode parses a StorageRetentionMode enum from string
func ParseStorageRetentionMode(input string) (StorageRetentionMode, error) {
	result := StorageRetentionMode(input)
	if !slices.Contains(enumValues_StorageRetentionMode, result) {
		return StorageRetentionMode(""), errors.New("failed to parse StorageRetentionMode, expect one of [Locked, Unlocked, Mutable, Delete]")
	}

	return result, nil
}

// IsValid checks if the value is invalid
func (j StorageRetentionMode) IsValid() bool {
	return slices.Contains(enumValues_StorageRetentionMode, j)
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StorageRetentionMode) UnmarshalJSON(b []byte) error {
	var rawValue string
	if err := json.Unmarshal(b, &rawValue); err != nil {
		return err
	}

	value, err := ParseStorageRetentionMode(rawValue)
	if err != nil {
		return err
	}

	*j = value
	return nil
}

// FromValue decodes the scalar from an unknown value
func (s *StorageRetentionMode) FromValue(value any) error {
	valueStr, err := utils.DecodeNullableString(value)
	if err != nil {
		return err
	}
	if valueStr == nil {
		return nil
	}
	result, err := ParseStorageRetentionMode(*valueStr)
	if err != nil {
		return err
	}

	*s = result
	return nil
}

// ScalarName get the schema name of the scalar
func (j StorageRetentionValidityUnit) ScalarName() string {
	return "StorageRetentionValidityUnit"
}

const (
	StorageRetentionValidityUnitDays  StorageRetentionValidityUnit = "DAYS"
	StorageRetentionValidityUnitYears StorageRetentionValidityUnit = "YEARS"
)

var enumValues_StorageRetentionValidityUnit = []StorageRetentionValidityUnit{StorageRetentionValidityUnitDays, StorageRetentionValidityUnitYears}

// ParseStorageRetentionValidityUnit parses a StorageRetentionValidityUnit enum from string
func ParseStorageRetentionValidityUnit(input string) (StorageRetentionValidityUnit, error) {
	result := StorageRetentionValidityUnit(input)
	if !slices.Contains(enumValues_StorageRetentionValidityUnit, result) {
		return StorageRetentionValidityUnit(""), errors.New("failed to parse StorageRetentionValidityUnit, expect one of [DAYS, YEARS]")
	}

	return result, nil
}

// IsValid checks if the value is invalid
func (j StorageRetentionValidityUnit) IsValid() bool {
	return slices.Contains(enumValues_StorageRetentionValidityUnit, j)
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StorageRetentionValidityUnit) UnmarshalJSON(b []byte) error {
	var rawValue string
	if err := json.Unmarshal(b, &rawValue); err != nil {
		return err
	}

	value, err := ParseStorageRetentionValidityUnit(rawValue)
	if err != nil {
		return err
	}

	*j = value
	return nil
}

// FromValue decodes the scalar from an unknown value
func (s *StorageRetentionValidityUnit) FromValue(value any) error {
	valueStr, err := utils.DecodeNullableString(value)
	if err != nil {
		return err
	}
	if valueStr == nil {
		return nil
	}
	result, err := ParseStorageRetentionValidityUnit(*valueStr)
	if err != nil {
		return err
	}

	*s = result
	return nil
}
